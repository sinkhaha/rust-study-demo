# 1 什么是类型系统

类型系统是对类型进行定义、检查和处理的系统。



**强类型和弱类型**：按定义后类型之间是否可以隐式转换划分

* 强类型语言：指不可以隐式转换（如： `Rust`、`Java`）
* 弱类型语言：指可以隐式转换（如：`JavaScript` ）



**静态类型系统和动态类型系统**：按类型的检查时机划分

* 静态类型系统：指在编译期进行类型检查，可进一步细分为显式静态和隐式静态（如：`Rust / Java` 是显式静态语言，`Haskell` 是隐式静态语言）
* 动态类型系统：指在运行期间进行类型检查（如：`JavaScript`）




# 2 类型安全

`Rust` 是一门类型安全的语言，因为

1、`Rust` 是 `强类型` 加 `静态类型系统` 的一门语言

* 在定义时， `Rust` 不允许类型的隐式转换，即 `Rust` 是强类型语言
* 同时在检查时，`Rust` 使用了静态类型系统，在编译期保证类型的正确

2、从内存的角度看，类型安全是指代码只能按照被允许的方法和被允许的权限(读 / 写)，访问它被授权访问的内存。

> 以一个长度为 4，存放 `u64` 数据的数组为例。当访问这个数组时，只能在这个数组的 `起始地址` 到 `结束地址`之间这 `32` 个字节的内存中访问，而且访问是按照 `8` 字节来对齐的，且数组中的每个元素只能做 `u64` 类型允许的操作。对此，编译器会对代码进行严格检查来保证这个行为。



![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/rust-chengxusheji/rust%E7%9A%84%E7%B1%BB%E5%9E%8B.drawio.png)



3、`Rust` 中除了 `let / fn / static / const` 这些定义性语句外，都是**表达式，而一切表达式都有类型**

例如：以下伪代码的类型是 `unit`，也就是 `()类型`，表示没有值

```rust
if has_work {
    do_something();
}
```

* `Rust` 中对于一个作用域，无论是 `if/else/for` 循环还是函数，最后一个表达式的返回值就是作用域的返回值。如果表达式或者函数不返回任何值，那么它返回一个 `unit()` 。`unit` 是只有一个值的类型，它的值和类型都是 `()` 

* `unit` 的应用场景除了作为返回值，还可以在数据结构中使用，例如

  > `Result<(), Error>` 表示返回的错误类型中，只关心错误，不关心成功的值；
  >
  > `HashMap<K, ()>` ，HashSet是`HashMap<K, ()>` 的一个类型别名



# 3 Rust 中的类型

作为静态类型语言，`Rust` 提供了大量的数据类型。 `Rust` 的原生类型如整数、浮点数、布尔值、字符、数组（`array`）、元组（`tuple`）、切片（`slice`）、指针、引用、函数等等。在原生类型的基础上，`Rust` 标准库还支持非常丰富的组合类型。常见的类型如下：

| 类型                                           | 说明                                                         | 值                                                           |
| ---------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `i8、i16、i32、i64、i128`                      | 给定位宽的有符号整数（比如 `i8`，`i` 表示有符号，8 表示 8 位，即大小） | 42、-5i8（是一个复数）、0o100i16（是一个带符号的八进制数）   |
| `u8、u16、u32、u64、u128`                      | 给定位宽的无符号整数（比如 `u8`，`u` 表示无符号，8 表示 8 位，即大小） | 0x400u16（是一个无符号十六进制数）、20_922_789_888_000u64（是一个无符号的64位数值）、b'*'（u8字节字面量） |
| `isize、usize`                                 | 与`机器字(32位 或 64位)`一样大的有符号整数 和 无符号整数；机器字是一个值，其大小等于运行此代码的机器上“地址”的大小，可能是32位，也可能是64位 | 137、-0b0101_0010isize、0xffff_fc00usize                     |
| `f32、f64`                                     | 单精度 `IEEE` 浮点数和双精度 `IEEE` 浮点数                   | 1.61803、3.14f32、6.0221e23f64                               |
|                                                |                                                              |                                                              |
| `bool`                                         | 布尔值                                                       | true、false                                                  |
| `char`                                         | `Unicode` 字符，32位宽(4个字节)                              | `'*'、'\n'、' 字 '、'\x7f'、'\u{CA0}'`                       |
|                                                |                                                              |                                                              |
| `(char, u8, i32)`                              | 元组，允许混合类型（这里有3个元素，也叫三元组）              | ('%',0x7f,-1)                                                |
| `()`                                           | “单元”(空元组)                                               | ()                                                           |
|                                                |                                                              |                                                              |
| `&T、&mut T（T 为具体类型，如&i32、&mut i32）` | 共享引用 和 可变引用：非拥有型指针，其生命周期不能超出引用目标 | `&s.y、&mut v`                                               |
|                                                |                                                              |                                                              |
| `&str`                                         | 对str的引用：指向UTF-8文本的非拥有型指针                     | `&s[0..12]、"123"`                                           |
| `String`                                       | UTF-8 字符串，**动态分配大小**                               | `"ramen".to_string()`                                        |
|                                                |                                                              |                                                              |
| `struct S { x: f32, y: f32}`                   | 具名字段型结构体                                             | S {x: 120, y: 209.0 }                                        |
| `struct T(i32, char);`                         | 元组型结构体                                                 | T(120, 'X')                                                  |
| `struct E;`                                    | 单元型结构体，无字段                                         | E                                                            |
|                                                |                                                              |                                                              |
| `enum Attend { OnTime, Late(u32) };`           | 枚举 或 代数数据类型                                         | `Attend::Late(5)、Attend::OnTime`                            |
|                                                |                                                              |                                                              |
| `Box<T>`                                       | 表示指向堆中类型 `T` 值的拥有型指针                          | `Box::new(1)`                                                |
|                                                |                                                              |                                                              |
| `[f64; 4]、[u8; 256]`                          | 数组，固定长度，其元素类型都相同；如[f64, 4]其中的 `f64` 表示类型是双精度浮点数，4表示有4个元素 | [1.0, 0.0, 0.0, 1.0]、[b' '; 256]                            |
| `Vec<f64>`                                     | 向量，可变长度，其元素类型都相同                             | `vec![0.367, 2.718, 7.389]`                                  |
| `&[u8]、&mut [u8]`                             | 对切片(数组或向量某一部分)的引用，包括指针和长度             | `&v[10..20]、&mut a[..]`                                     |
|                                                |                                                              |                                                              |
| `Option<&str>`                                 | 可选值：或为 `None` (无值)，或为` Some(v)`（有值，其值为 v） | `Some("Dr.")，None`                                          |
|                                                |                                                              |                                                              |
| `Result<u64, Error>`                           | 可能失败的操作结果：或为成功值 `Ok(v)`，或为错误值 `Err(e)`  | `Ok(4096)，Error(Error::last_os_error())`                    |
|                                                |                                                              |                                                              |
| `&dyn Any、&mut dyn Read`                      | 特型对象，是对任何实现了一组给定方法的值的引用               | `value as &dyn Any、&mut file as &mut dyn Read`              |
|                                                |                                                              |                                                              |
| `RefCell<T>`                                   | 为类型 T 提供内部可变性的智能指针                            | `let v = RefCell::new(18);<br>let mut borrowed = v.borrow_mut(); |
|                                                |                                                              |                                                              |
| `Rc<T> / Arc<T>`                               | 为类型 T 提供引用计数的智能指针                              | let v = Rc::new(18);<br>let v1 = Arc::new(18);               |
|                                                |                                                              |                                                              |
| `fn(&str) -> bool`                             | 函数指针                                                     | str::is_empty                                                |
|                                                |                                                              |                                                              |
| `*const T`、`*mut T`                           | 裸指针，裸指针在解引用时是不安全的                           | let x = 42; <br>let mut y = 24; <br>let raw = &x as *const i32; <br>let raw_mut = &mut y as *mut i32; |
| `HashMap<K, V>`                                | 哈希表                                                       | let v: HashMap<&str, &str> = HashMap::new();                 |
|                                                |                                                              |                                                              |
| `HashSet<T>`                                   | 集合                                                         | `let v: HashSet<i32> = HashSet::new();`                      |
|                                                |                                                              |                                                              |
| (闭包类型没有显示书写形式)                     | 闭包                                                         | \|a,b\| a * a + b * b                                        |



## 3.1 类型别名

`Rust` 中可以用 **“`type`  别名”** 为类型声明一个新名称。例如为 `Vec<u8>` 类型其一个叫 `Bytes` 的别名，此时  `Bytes`  就是 `Vec<u8>` 的简写，如

```rust
type Bytes = Vec<u8>;
```



## 3.2 固定宽度的数值类型

### 3.2.1 整型

`Rust` 类型系统的根基是一组固定宽度的数值类型。固定宽度的数值类型可能会溢出或丢失精度。



**u8 类型字节值**

`Rust` 会使用 `u8` 类型作为字节值。例如从二进制文件或套接字中读取数据时会产生一个 `u8` 值构成的流。注意 `Rust` 会把字符视为与数值不同的类型，`char` 既不是 `u8`，也不是 `u32`。



**usize类型**

`Rust` 的数组索引是 `usize` 值，用来表示数组 或 向量大小 或 某些数据结构中元素数量的值通常也是 `usize` 类型。



**后缀标识**

`Rust` 中的整型字面量可以带上一个后缀表示它们的类型：

* 如 `42u8` 表示这个 42 是 `u8` 类型，`1729isize` 是 `isize` 类型
* 如果没指定，`Rust` 会自动推断确定其类型，如果推断出有多种可选类型，`Rust` 会默认使用 `i32`，否则报错



**不同进制表示法的前缀**

| 进制           | 前缀 |
| -------------- | ---- |
| 十六进制字面量 | 0x   |
| 八进制字面量   | 0o   |
| 二进制字面量   | 0b   |



**字节字面量**

虽然数值类型和 `char` 类型是不相同的，但是 `Rust` 为 `u8` 值提供了`字节字面量`。与字符字面量类似，`b'X'` 表示以字符 `X` 的 `ASCII` 码作为 `u8` 的值，例如 `A` 的 `ASCII` 码是 65，因此字面量 `b'A'` 和 `65u8`  完全等价。只有 `ASCII` 字符才能出现在字节字面量中。但要注意，有几个字符不能直接放在单引号后面，需要添加 `\` 转义，如

| 字符            | 字节字面量 | 等效的数值 |
| --------------- | ---------- | ---------- |
| 单引号（'）     | `b'\''`    | 39u8       |
| 反斜杠（\）     | `b'\\'`    | 92u8       |
| 换行（lf）      | `b'\n'`    | 10u8       |
| 回车（cr）      | `b'\r'`    | 13u8       |
| 制表符号（tab） | `b'\t'`    | 9u8        |



**类型转换**

`as` 运算符：将一种类型转换为另一种类型，如

```rust
assert_eq!(10_i8 as u16, 10_u16); // 此断言能正常通过，本来10是i8类型，但是用as转成u16类型
```

截断：超过目标范围的转换生成的值等于原始值对 `2^N` 取模的值，其中 `N` 是安位算的目标宽度，如

```rust
assert_eq!(1000_i16 as u8, 232_u8); //此时也是等价的，因为 u8最大255，1000_i16转成u8时超过范围了，最终等于232_u8； 因为2的8次方是256，1000 % 256为232
```



### 3.2.2 浮点类型

`Rust` 提供了 `IEEE` 单精度和 `IEEE` 双精度的浮点类型，如

| 类型 | 精度                     | 范围                                |
| ---- | ------------------------ | ----------------------------------- |
| f32  | IEEE单精度(至少6位小数)  | 大约 -3.4 * 10^38 至 +3.4 * 10^38   |
| f64  | IEEE双精度(至少15位小数) | 大约 -1.8 * 10^308 至 +1.8 * 10^308 |

浮点数字面量的一般化形式为`31415.926e-4f64`，这个数是 `31415.92 乘以 10 的 -4 次方`

* `31415`：是整数部分
* `.926`：是浮点部分
* `e - 4`: 是指数，表示将小数点向左移动4位，即10的-4次方
* `f64`：是类型后缀，为双精度浮点数

浮点数中整数部分之后的每个部分都是可选的，但必须至少存在小数部分、指数或类型后缀这三者中的一个，小数部分可以仅由一个点组成，类型后缀默认是 `f64`。比如 `2.`、`0.25`、`1e4` 、`40f32`、`-1.5625`



**f32 和 f64 类型具有IEEE要求点一些特殊值的关联常量**

* `INFINITY`：无穷大

* `NEG_INFINITY`：负无穷大

* `NAN`：非数值

* `MIN`：最小有限值

* `MAX`：最大有限值

```rust
assert_eq!(-f32::MIN, f32::MAX);
```



注意：`Rust` 几乎不会执行任何隐式的数值转换。必须使用 `as` 进行显示转换



## 3.3 布尔类型

`Rust` 中，`if` 和 `while` 这样的语句要求它们的条件必须是 `bool 表达式`，短路逻辑运算符 `&&` 和 `||` 也是如此。比如必须写成 `if x != 0 {...}`，不能写成 `if x { ... }`。



`Rust` 的 `as` 运算符可以把 `bool` 值转换成整型，但是不能反向转换，如

```rust
assert_eq!(false as i32, 0); // 此时false转成了0
assert_eq!(true as i32, 1); // 此时true转成了1
```



## 3.4 字符

`Rust` 的字符类型 `char` 会以 `4个字节` 表示单个 `Unicode` 字符；但是对字符串和文本流使用 `UTF-8` 编码，所以 `String` 类型会将其文本表示为 `UTF-8` 字节序列，而不是字符数组。



字符字面量是用**单引号**括起来的字符，比如 `'8'`。与字节字面量一样，有些字符需要用**反斜杠**转义，如

| 字符        | rust字符字面量 |
| ----------- | -------------- |
| 单引号 (')  | `'\''`         |
| `反斜杠(\)` | `'\\'`         |
| 换行(lf)    | `'\n'`         |
| 回车(cr)    | `'\r'`         |
| 制表(tab)   | `'\t'`         |



`Rust` 不会在 `char` 和任何其他类型之间进行隐式转换，但可以使用 `as` 将 `char` 转换为整型，而 `u8` 是唯一能通过 `as` 转换成 `char` 类型的。



## 3.5 元组

元组是包裹在一对括号，元素用**逗号**分隔的元素序列，有几个元素就称为几元组，元组里的每个元素可以有不同的类型。比如`("a", 12)`是一个元组，它的类型是`(&str, i32)`

* 空元组：如果只是一对括号，里面没有元素，则称为空元组，即`()`

* 单值元组：即只包含单个元素的元组，必须在值后面添加逗号

  > 比如 ` ("hello",)`是一个包含单个字符串的元组，括号后面的逗号是必须的，它的类型是 `(&str,)` ，括号里的逗号用于区分单值元组和简单括号表达式，如果不加逗号，它是类型就是 `&str`



访问元组元素：比如一个元组值 `t`，可以通过 `t.0`，`t.1` 访问其元素，元组只允许用常量做索引，不能写成 `t.i` 或 `t[i]` 的形式来获取第 `i` 个元素。



元组类型的作用：通常用于一个函数返回多个值，例如

```rust
fn main() {
    let text = "hello world";

    let (head, tail) = text.split_at(2); // split_at返回一个(&str, &str)的元组类型
    // 等价于
    // let temp = text.split_at(2);
    // let head = temp.0;
    // let tail = temp.1;

    println!("{} {}", head, tail); // he llo world
}

```



## 3.6 指针类型

下面介绍 3 种指针类型：引用、`Box` 和 不安全指针



### 3.6.1 引用

可以将引用视为 `Rust` 中的基本指针类型。表达式 `&x` 会生成一个对 `x` 的引用，可以称为借用了对 `x` 的引用。

* `&String` 类型的值是对 `String` 值的引用

* `&i32` 是对 `i32` 的引用

  > 在运行期间，对 `i32` 的引用是一个保存着 `i32` 地址的机器字，这个地址可能位于栈或堆中



`Rust`  中的两种引用方式

* `&T`：表示一个不可变的，共享的引用。可以同时拥有多个对给定值的共享引用，它们是只读的，禁止修改它们所指向的值
* `&mut T`：表示一个可变的，独占的引用。可以读取和修改它们指向的值。因为是独占的，只要该可变引用还存在，就不能对该值有其他任何类型的其他引用

同一个作用域内，共享引用和独占引用只能二选一，或者独占读写一个值，或者让任意数量的读取者共享。



解引用：给定一个引用 `r`，表达式 `*r` 则是解引用，用于获取引用 `r` 所指向的值。



### 3.6.2 Box

`Box` 是指向堆中值的拥有型指针，`Box::new` 会在堆中分配值，如

```rust
let t = (12, "egg");
let b = Box::new(t); // 会在堆中分配一个元组
```

当 `b` 超过作用域时，内存会立即被释放，除非 `b` 已经被移动 `move`，比如返回它



### 3.6.3 裸指针

`Rust` 的裸指针类型是 `*mut T` 和 `*const T`，使用裸指针是不安全的，因为 `Rust` 不会跟踪它指向的内容 ，例如裸指针可能为空， 或者 它可能指向已经释放的内存 或 现在包含不同类型的值。



只能在 `unsafe` 块中对裸指针解引用。



## 3.7 数组、向量、切片

### 3.7.1 数组

类型 `[T, N]` 表示 `N` 个值的数组，每个值的类型是 `T`。因为数组的大小在编译期就确定的，并且是类型的一部分，所以 `N` 不能是一个变量，必须是一个固定的数字，数组也不能追加新元素或缩小数组。



注意：数组上一些方法(遍历元素、排序、过滤等)都是作为**切片**提供的，而不是数组提供的。但是 `Rust` 会隐式的将对数组的引用转换为切片，因为可以直接在数组上调用任何的切片方法，如

```rust
 let mut num = [4, 5, 3, 1, 2];
 num.sort();
 assert_eq!(num, [1, 2, 3, 4, 5]);
```

例子中 `sort` 方式实际是在切片定义的，但是它是通过引用获取的操作目标，所以 `Rust` 会隐式的生成一个引用整个数组的 `&mut [i32]` 的切片，并将其传给 `sort` 来进行操作



### 3.7.2 向量

类型 `Vec<T>` 称为类型 `T` 的向量，是一个动态分配且可增长的 `T` 类型的值序列。向量的元素存在于`堆`中，可以调整向量的大小，往任意位置追加或删除元素等。



创建向量的方式：使用 `vec!` 宏，如 `let mut nums = vec![2, 3, 4];`。`vec!` 宏相当于调用 `Vec::new` 来创建一个新的空向量，然后用 `push` 将元素放入其中

```rust
let mut pal = Vec::new();
pal.push(1);
pal.push(2);

assert_eq!(pal, vec![1, 2]);
```

和数组一样，可以对向量使用切片的方法 



### 3.7.3 切片

切片是数组或向量中的一个区域。由于切片可以是任意长度的，所以它不能直接存储在变量中 或 作为函数参数进行传递。**切片总是通过引用传递。**

* 类型 `&[T]` ：表示 `T` 的共享切片，允许多个读取者之间共享访问权限，但是不允许修改元素

* 类型 `&mut [T]` ：表示 `T` 的可变切片，允许读取和修改元素，但是不能共享

它们是对一系列元素的引用，这些元素是数组或向量的一部分。可以将切片视为指向其第一个元素的指针。



对切片的引用是一个胖指针：即一个双字值，包括指向切片第一个元素的指针 和 切片中元素的数量，例如

```rust
let v: Vec<f64> = vec![0.0, 0.707, 1.0, 0.707];
let a: [f64; 4] = [0.0, -0.707, -1.0, -0.707];

let sv: &[f64] = &v; // &v的类型原本是 &Vec<f64>
let sa: &[f64] = &a; // &v的类型原本是 &[f64; 4]
```

最后两行，`Rust` 自动把 `&Vec<f64>` 的引用和 `&[f64; 4]` 的引用转换成了直接指向数据的切片引用，如下图内存中向量 `v` 和 数组 `a` 分别被切片 `sa` 和 `sv` 引用



![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/rust-chengxusheji/%E5%88%87%E7%89%87.png)



## 3.8 字符串类型

### 3.8.1 字符串字面量

字符串字面量要用**双引号**括起来，其中的单引号不需要用反斜杠转义，而双引号需要，如

```rust
let speech = "\"ab\" hello ' world"; // "ab" hello ' world
```



字符串可以用 `\ 反斜杠`结尾换行，如

```rust
// it was a bright there were four more or less
let speech: &str = "it was a bright \
    there were four \
    more or less";
```



字符串支持 `==` 和  `!=`  运算符，如果两个字符串以相同的顺序包含相同的字符，则它们相等，如

```rust
let a: String = "ONE".to_lowercase();
let b: &str = "one";

assert_eq!(a, b); // 相等
```

字符串也支持比较运算符 `<、<=、>、>=`



### 3.8.2 字节串

字节串：带有 `b` 前缀的字符串字面量。这样的字节串是 `u8`（字节） 的切片而不是 `unicode` 文本，如

```rust
let method: &[u8; 3] = b"get"; // method的类型是 &[u8; 3]，它是对3字节数组的引用
assert_eq!(method, &[b'g', b'e', b't']);

println!("{:?}", method); // [103, 101, 116]
```



### 3.8.3 内存中的字符串

`Rust` 中的字符串是 `Unicode` 字符序列，但是并不是以 `char` 数组的形式存储在内存中，而是使用 `UTF-8` 的形式。字符串中的每个 `ASCII` 字符 都会存储在单字节中，而其他字符会占多字节。如

```rust
let noodles: String = "noodles".to_string();

let oodles: &str = &noodles[1..];

let poodles: &str = "test"; // 4个字节
```

如图 `String`、`&str` 和 `str`

![](https://sink-blog-pic.oss-cn-shenzhen.aliyuncs.com/img/rust-chengxusheji/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.png)



* `String` 有一个可以调整大小的缓冲区，其中包含 `UTF-8` 文本。缓冲区是在堆上分配的，所以可以根据需要来调整大小。上面 `noodles` 是一个 `String` ，拥有一个 8 个字节的缓冲区，其他 7个字节在使用。可以将 `String` 视为 `Vec<u8>`

* `&str` 是对别人拥有的一系列 `UTF-8` 文本的引用，即它“借用”了这个文本。`oodles` 是对 `noodles` 拥有的文本的最后 6 字节的一个引用。与其他切片引用一样，`&str` 也是一个指向某些数据的胖指针，包含实际数据的地址和长度。可以把 `&str` 认为是 `&[u8]`
* 字符串字面量是指预分配文本的 `&str`，它通常与程序的机器码一起存储在只读内存区。比如 `poodles` 是一个字符串字面量，指向一块 4 字节的内存，它在程序开始执行时就已经创建并一直到存在到程序退出。



`String` 或 `&str` 的 `len()` 方法会返回其长度，不过这个长度的以**字节**为单位，而不是**字符**为单位。



注意：`&str` 是不能修改的，要在运行期间创建新的字符串，可以使用 `String`，如

```rust
let mut s: &str = "hello";
s[0] = 'c'; // 错误，不能修改
```



### 3.8.4 String

与 `Vec` 一样，每个 `String` 都在堆上分配了自己的缓冲区，其中包含 `UTF-8` 文本，不会与任何其他 `String` 共享，缓冲区可以调整大小。当 `String` 变量超过作用域时，缓冲区将自动释放，除非这个 `String` 已经被移动。 `String` 类似 `Vec<T>`，而`&str` 类似 `&[T]`。



**`Vec<T>` 和 String 的对比**

|                                               | `Vec<T>`             | String              |
| --------------------------------------------- | -------------------- | ------------------- |
| 自动释放缓冲区                                | 是                   | 是                  |
| 可增长                                        | 是                   | 是                  |
| 类型关联函数 `::new()` 和 `::with_capacity()` | 是                   | 是                  |
| `.reserve()` 方法 和` .capacity()` 方法       | 是                   | 是                  |
| `.push()` 方法 和 `.pop()` 方法               | 是                   | 是                  |
| 范围语法 `v[start .. stop]`                   | 是，返回 `&[T]`      | 是，返回 `&str`     |
| 自动转换                                      | `&Vec<T>`  到 `&[T]` | `&String` 到 `&str` |
| 继承的方法                                    | 来自 `&[T]`          | 来自 `&str`         |



**创建 String 的几种方法**

* `.to_string()` ：会将 `&str` 转换为 `String`，这会复制此字符串

  > `.to_owned()` 方法也一样

* `format!()` 宏：它的工作方式和 `println!()`类似，会返回一个新的 `String`，而不是将文本写入标准输出，并且不会在末尾自动添加换行符

  ```rust
  assert_eq!(format!("{} {:02} {:02}", 24, 5, 23), "24 05 23".to_string());
  ```

* 字符串的数组、切片 和向量都有两个方法（`.concat() 和 .join(sep)`），它们会返回一个新的 `String`

  ```rust
  let bits: Vec<&str> = vec!["zhangsan", "lisi"];
  let a: String = bits.concat();
  assert_eq!(a, "zhangsanlisi");
  
  assert_eq!(bits.join(","), "zhangsan,lisi");
  ```

  

### 3.8.5 其他类似字符串的类型

`Rust` 保证字符串是有效的 `UTF-8`。有时程序需要处理不是有效 `Unicode` 的字符串，比如一个名字不符合`Unicode` 规则的文件。`Rust` 的解决方案是为这些情况提供一些类似字符串的类型

* 对于`Unicode` 文本，坚持使用 `String` 和 `&str`
* 当使用文件名时，改用 `std::path::PathBuf` 和 `&Path`
* 当处理根本不是 `UTF-8` 编码的二进制数据时，使用 `Vec<u8>` 和 `&[u8]`
* 当使用操作系统提供的原生形式的环境变量名和命令行参数时，使用 `OsString` 和 `&OsStr`
* 当和使用 `null` 结尾字符串的 `C` 语言库进行互相操作时，使用 `std::ffi::CString` 和 `&CStr`



# 4 类型推导

`Rust` 支持局部的类型推导，在一个作用域之内，`Rust` 编译器可以根据变量的上下文，推导出变量的类型，这样就不需要显式地进行类型标注。



注意：常量和静态变量的定义，即使上下文中含有类型的信息，也需要为变量提供类型。

> 因为 `const / static` 主要用于定义全局变量，它们可以在不同的上下文中使用，所以为了代码的可读性，需要明确的类型声明。

```rust
const PI: f64 = 3.1415926;
static E: f32 = 2.71828;

fn main() {
    const V: u32 = 10;
    static V1: &str = "hello";
    println!("PI: {}, E: {}, V {}, V1: {}", PI, E, V, V1);
}
```



**正确推导出类型的例子**

```rust
use std::collections::BTreeMap;

fn main() {
    let mut map = BTreeMap::new();
    map.insert("hello", "world");
    println!("map: {:?}", map);
}
```

`Rust` 可推导出 `BTreeMap` 的类型 `K` 和 `V` 都是字符串引用 `&str`；如果把 `map.insert` 语句注释去掉，`Rust` 编译器就会报错：`“cannot infer type for type parameter K”`。



**无法推导出类型的例子**

```rust
// 把列表中的偶数过滤出来，生成一个新的列表
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let even_numbers = numbers
        .into_iter()
        .filter(|n| n % 2 == 0)
        .collect(); // collect()是 Iterator trait 的方法，作用是把一个 iterator 转换成一个集合

    println!("{:?}", even_numbers);
}
```

因为很多集合类型(如 `Vec<T>、HashMap<K, V>`)都实现了 `Iterator`，所以编译器无法从上下文中推断出`collect()` 要返回什么类型。

* 改正方式1：声明 `even_numbers` 为类型 `Vec<_>`

> 注意：编译器只是无法推断出集合类型，但集合类型内部元素的类型，还是可以根据上下文得出，所以简写成` Vec<_> `

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let even_numbers: Vec<_> = numbers
        .into_iter()
        .filter(|n| n % 2 == 0)
        .collect();

    println!("{:?}", even_numbers);
}
```

* 改正方式2（`turbofish` 写法）：让 `collect` 返回一个明确的类型；在泛型函数后使用 `::` 来强制使用类型 `T`，这种写法被称为 `turbofish` 比目鱼，代码会更简洁。

```rust
fn main() {
    let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

    let even_numbers = numbers
        .into_iter()
        .filter(|n| n % 2 == 0)
        .collect::<Vec<_>>();

    println!("{:?}", even_numbers);
}
```



# 5 参考

* [Rust程序设计（第2版）](https://book.douban.com/subject/36547630/)

* [陈天 · Rust 编程第一课](https://time.geekbang.org/column/article/420028)

  
